In this module, I moved from “just making it work” to thinking more seriously about security and reliability. Implementing a hashed `password_hash` field with tools like bcrypt showed me why passwords should never be stored in plain text and how one-way hashing plus verification functions protect users even if the database is compromised. Using Pydantic schemas (especially `UserCreate` vs `UserRead`) helped me clearly separate what data can be accepted from clients and what should be returned, and I gained a better appreciation for built-in validation like `EmailStr` to reject bad input before it reaches the database.

The biggest hurdles were wiring up environment variables and database URLs for tests in GitHub Actions, and getting Docker Hub authentication right in the CI/CD pipeline. I resolved these by externalizing sensitive values into GitHub Secrets, carefully matching them in the workflow YAML, and using a Postgres service container for integration tests. Seeing the pipeline run tests, build the image, and push to Docker Hub only when everything passed gave me a concrete sense of how automated testing and deployment reduce human error and make the project feel “production ready,” not just like a homework assignment.
